# SDS——simple Dynamic String

#### 1.结构

```go
type Sds struct {
	len  int
	free int
	buf  []byte
}
```

![](C:\Users\weiyaqi\Desktop\github\notes\redis\图片\0880c08b011095becf0f.jpeg)

len：表示字符串的长度为5

free：表示还有4个存储空间

buf：表示存储字符串的结构，buf采用c字符串的格式存储数据

‘ \0’: 代表结束标志，不记录到len 和 free 里，相当于透明的

#### 2.SDS与C字符串的区别

1.读取字符串长度的时间复杂度为O(1)，SDS直接在len中维护长度即可，C字符串需要遍历一遍，然后求长度。

2.杜绝缓冲区溢出、避免内存泄漏：C字符串增加时需要额外分配内存空间，否则会发生缓存区溢出，而SDS在增加字符串长度时只需要和free比较即可；C字符串在缩短字符串长度时需要有内存回收，否则会有内存泄漏问题，而SDS只需要将缩短的长度加到free上即可(惰性空间释放)

3.减少了修改字符串所带来的内存重新分配次数：C字符串每次增加或者缩短操作都会使用内存重分配操作，一般来说，如果修改字段不是很长的情况下，这是完全可以接受的，但是在redis这种追求速度和效率的情况下，这是完全不能接受的，所以SDS有空间预分配策略(下面细讲)。

#### 3.SDS的空间预分配和惰性空间释放

1.空间预分配策略， 如果分配完成之后，len的长度小于1MB，那么就会多分配一倍的长度。eg：如果分配完成后len = 13，那么就会将buf的总长度分配为13+13+1 = 27,1字节来保存空字符(透明)；如果分配完成之后len的长度大于1MB，那么只会多分配1MB的长度，eg：如果分配完成后len的长度是30MB，那么buf的总长度会是30MB+1+1MB。

2.惰性空间释放：SDS缩短字符串时，不会立马进行空间的重新分配，而是将缩短的字符串长度添加至free中，减少分配次数，提升效率，如果需要回收时。会调用api回收。

#### 4.二进制安全

SDS可以保存任意形式的数据，SDS的API都是二进制安全的，buf也被称为字节数组。

#### 5.额外

SDS的buf中采用和c字符串的格式('\0 代表结尾')保存数据，是为了在一些API上可以直接调用C的现有的API

